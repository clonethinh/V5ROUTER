#!/bin/sh
set -euo pipefail
IFS=$'\n\t'

echo "Content-Type: application/json; charset=utf-8"
echo ""

# === DEBUG LOG ===
DEBUG_LOG="/tmp/sms-read-debug.log"
MAX_LOG_SIZE=10485760  # 10MB

debug() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $1" >> "$DEBUG_LOG"
    
    # Rotate log if too large
    if [ -f "$DEBUG_LOG" ] && [ $(stat -f%z "$DEBUG_LOG" 2>/dev/null || stat -c%s "$DEBUG_LOG" 2>/dev/null || echo 0) -gt $MAX_LOG_SIZE ]; then
        mv "$DEBUG_LOG" "${DEBUG_LOG}.old"
        echo "[$timestamp] Log rotated" > "$DEBUG_LOG"
    fi
}

# Redirect stderr to debug log
exec 2>> "$DEBUG_LOG"

debug "=== SMS-READ START ==="

# === CẤU HÌNH ===
ARCHIVE_DIR="/root/sms-archive"
mkdir -p "$ARCHIVE_DIR"

CURRENT_MONTH=$(date "+%Y-%m")
MONTHLY_FILE="$ARCHIVE_DIR/messages-${CURRENT_MONTH}.json"
TEMP_FILE="/tmp/messages_temp_$$.json"
LOCK_FILE="/root/sms-read.lock"

debug "Monthly file: $MONTHLY_FILE"

# === KIỂM TRA DEPENDENCIES ===
check_dependencies() {
    local missing=""
    for cmd in jq mmcli; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing="${missing}$cmd "
        fi
    done
    
    if [ -n "$missing" ]; then
        debug "Missing dependencies: $missing"
        echo '{"error": "Missing dependencies: '"$missing"'", "messages": []}'
        exit 1
    fi
}

check_dependencies

# === ESCAPE JSON SAFELY ===
escape_json_text() {
    local text="$1"
    # Sử dụng jq để escape đúng chuẩn JSON
    jq -Rn --arg s "$text" '$s'
}

# === KHỞI TẠO MONTHLY FILE ===
init_monthly_file() {
    if [ ! -f "$MONTHLY_FILE" ] || [ ! -s "$MONTHLY_FILE" ]; then
        debug "Creating/recreating monthly file"
        
        local current_month_init=$(date "+%Y-%m")
        local current_timestamp=$(date "+%Y-%m-%d %H:%M:%S")
        
        cat > "$MONTHLY_FILE" << EOF
{
  "month": "$current_month_init",
  "messages": [],
  "total": 0,
  "last_updated": "$current_timestamp"
}
EOF
    else
        debug "Monthly file exists, validating JSON"
        if ! jq . "$MONTHLY_FILE" >/dev/null 2>&1; then
            debug "Monthly file corrupt, recreating"
            
            # Backup corrupted file
            cp "$MONTHLY_FILE" "${MONTHLY_FILE}.corrupted.$(date +%s)" 2>/dev/null || true
            
            local current_month_init=$(date "+%Y-%m")
            local current_timestamp=$(date "+%Y-%m-%d %H:%M:%S")
            
            cat > "$MONTHLY_FILE" << EOF
{
  "month": "$current_month_init", 
  "messages": [],
  "total": 0,
  "last_updated": "$current_timestamp"
}
EOF
        fi
    fi
}

# === ROBUST SMS ID PARSING ===
parse_sms_ids() {
    local json_output="$1"
    debug "Raw SMS_LIST_JSON: $json_output"
    
    # Method 1: Try new JSON structure (."modem.messaging.sms" array)
    if SMS_IDS_NEW=$(echo "$json_output" | jq -r '."modem.messaging.sms" // [] | map(split("/")[-1]) | .[]' 2>/dev/null) && [ -n "$SMS_IDS_NEW" ]; then
        debug "JSON parsing successful with new structure"
        echo "$SMS_IDS_NEW"
        return 0
    fi
    
    # Method 2: Try old JSON structure (.modem.messaging.sms object)
    if SMS_IDS_OLD=$(echo "$json_output" | jq -r '.modem.messaging.sms // [] | keys[]' 2>/dev/null) && [ -n "$SMS_IDS_OLD" ]; then
        debug "JSON parsing successful with old structure"
        echo "$SMS_IDS_OLD"
        return 0
    fi
    
    # Method 3: Text parsing fallback
    debug "All JSON parsing failed, using text parsing fallback"
    mmcli -m 0 --messaging-list-sms 2>/dev/null | grep -o 'SMS/[0-9]*' | cut -d'/' -f2
}

# === FILE LOCKING ===
exec 200>"$LOCK_FILE"
if ! flock -n 200; then
    debug "Could not acquire lock"
    echo '{"error": "Another instance is running", "messages": []}'
    exit 1
fi

init_monthly_file

# === KIỂM TRA MESSAGE ĐÃ TỒN TẠI ===
message_exists() {
    local sms_id="$1"
    jq -e --arg id "$sms_id" '.messages[] | select(.id == ($id | tonumber))' "$MONTHLY_FILE" >/dev/null 2>&1
}

# === THÊM MESSAGE VÀO MONTHLY FILE ===
add_to_monthly() {
    local new_message="$1"
    debug "Adding message to monthly file"
    
    # Backup
    cp "$MONTHLY_FILE" "${MONTHLY_FILE}.backup" 2>/dev/null || {
        debug "Failed to create backup"
        return 1
    }
    
    # Validate new message JSON
    echo "$new_message" > "/tmp/new_msg_$$.json"
    
    if ! jq . "/tmp/new_msg_$$.json" >/dev/null 2>&1; then
        debug "New message JSON is invalid"
        rm -f "/tmp/new_msg_$$.json"
        return 1
    fi
    
    debug "New message JSON is valid"
    
    local current_timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Use jq to safely add message
    if jq --slurpfile new_msg "/tmp/new_msg_$$.json" \
       --arg timestamp "$current_timestamp" '
        .messages += $new_msg |
        .messages |= unique_by(.id) |
        .total = (.messages | length) |
        .last_updated = $timestamp
    ' "$MONTHLY_FILE" > "$TEMP_FILE" 2>/tmp/jq_error_$$.log; then
        
        rm -f "/tmp/new_msg_$$.json"
        
        if [ -s "$TEMP_FILE" ] && jq . "$TEMP_FILE" >/dev/null 2>&1; then
            mv "$TEMP_FILE" "$MONTHLY_FILE"
            debug "Successfully added message to monthly file"
            rm -f "${MONTHLY_FILE}.backup"
            return 0
        else
            debug "jq processing failed or temp file invalid"
            if [ -f "/tmp/jq_error_$$.log" ]; then
                debug "jq error: $(cat /tmp/jq_error_$$.log)"
            fi
        fi
    else
        debug "jq command failed"
        if [ -f "/tmp/jq_error_$$.log" ]; then
            debug "jq error: $(cat /tmp/jq_error_$$.log)"
        fi
    fi
    
    # Rollback on failure
    if [ -f "${MONTHLY_FILE}.backup" ]; then
        mv "${MONTHLY_FILE}.backup" "$MONTHLY_FILE"
        debug "Rolled back to backup"
    fi
    
    # Cleanup
    rm -f "/tmp/new_msg_$$.json" "/tmp/jq_error_$$.log" "$TEMP_FILE"
    return 1
}

# === MAIN PROCESSING ===
debug "Starting main processing"

PROCESSED_COUNT=0
SKIPPED_COUNT=0

# Kiểm tra modem có sẵn sàng không
if ! mmcli -L 2>/dev/null | grep -q "/Modem/0"; then
    debug "No modem found"
    echo '{"error": "No modem found", "messages": []}'
    exit 1
fi

# 1. LẤY DANH SÁCH SMS TỪ MODEM (dùng JSON output)
debug "Getting SMS list from modem"
if ! SMS_LIST_JSON=$(mmcli -m 0 --messaging-list-sms --output-json 2>/dev/null); then
    debug "Failed to get SMS list"
    echo '{"error": "Failed to get SMS list", "messages": []}'
    exit 1
fi

# Extract SMS IDs using robust parsing
SMS_IDS=$(parse_sms_ids "$SMS_LIST_JSON" | sort -nr)
debug "Extracted SMS IDs (sorted desc): $(echo $SMS_IDS | tr '\n' ' ')"

# 2. XỬ LÝ TIN NHẮN MỚI
for ID in $SMS_IDS; do
    [ -n "$ID" ] || continue
    
    debug "Processing SMS ID: $ID"
    
    # Kiểm tra message đã tồn tại chưa
    if message_exists "$ID"; then
        debug "SMS $ID already exists, skipping"
        SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
        continue
    fi
    
    # Lấy thông tin SMS bằng JSON
    if ! SMS_INFO_JSON=$(mmcli -s "$ID" --output-json 2>/dev/null); then
        debug "Failed to get info for SMS $ID"
        continue
    fi
    
    # Extract thông tin từ JSON
    NUMBER=$(echo "$SMS_INFO_JSON" | jq -r '.sms.content.number // ""')
    RAW_TEXT=$(echo "$SMS_INFO_JSON" | jq -r '.sms.content.text // ""')
    TYPE=$(echo "$SMS_INFO_JSON" | jq -r '.sms.properties["pdu-type"] // ""')
    STATE=$(echo "$SMS_INFO_JSON" | jq -r '.sms.properties.state // ""')
    DATE=$(echo "$SMS_INFO_JSON" | jq -r '.sms.properties.timestamp // ""')
    
    debug "SMS $ID - Number: $NUMBER, Text length: ${#RAW_TEXT}, Type: $TYPE, State: $STATE"
    
    # Bỏ qua tin nhắn không hợp lệ (chỉ skip nếu không có text)
    if [ -z "$RAW_TEXT" ]; then
        debug "SMS $ID has no text, skipping"
        continue
    fi
    
    # Chuẩn hóa timezone format
    if echo "$DATE" | grep -qE '\+[0-9]{2}$'; then
        DATE=$(echo "$DATE" | sed 's/+\([0-9][0-9]\)$/+\1:00/')
    fi
    
    # Escape JSON safely
    TEXT_ESC=$(escape_json_text "$RAW_TEXT")
    NUMBER_ESC=$(escape_json_text "$NUMBER")
    
    # Xác định read_status
    READ_STATUS=1
    if [ "$TYPE" = "deliver" ]; then
        READ_STATUS=0
    fi
    
    # Tạo JSON message
    NEW_MESSAGE=$(jq -n \
        --arg id "$ID" \
        --argjson number "$NUMBER_ESC" \
        --argjson text "$TEXT_ESC" \
        --arg date "$DATE" \
        --arg type "$TYPE" \
        --arg state "$STATE" \
        --arg storage "router" \
        --arg read_status "$READ_STATUS" \
        '{
            id: ($id | tonumber),
            number: $number,
            text: $text,
            date: $date,
            type: $type,
            state: $state,
            storage: $storage,
            read_status: ($read_status | tonumber)
        }')
    
    debug "Created JSON for SMS $ID"
    
    # Lưu vào archive
    if add_to_monthly "$NEW_MESSAGE"; then
        debug "Successfully saved SMS $ID to archive"
        
        # Xóa SMS khỏi SIM sau khi lưu thành công
        if mmcli -m 0 --messaging-delete-sms="$ID" >/dev/null 2>&1; then
            debug "Successfully deleted SMS $ID from SIM"
            PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
        else
            debug "WARNING: Failed to delete SMS $ID from SIM - may cause duplicate"
        fi
    else
        debug "Failed to save SMS $ID to archive"
    fi
done

debug "Finished processing. New: $PROCESSED_COUNT, Skipped: $SKIPPED_COUNT"

# 3. DEDUPLICATION VÀ SORT CUỐI CÙNG
debug "Final deduplication and sorting"
jq '.messages |= (unique_by(.id) | sort_by(.id) | reverse) | .total = (.messages | length)' "$MONTHLY_FILE" > "$TEMP_FILE"

if [ -s "$TEMP_FILE" ] && jq . "$TEMP_FILE" >/dev/null 2>&1; then
    mv "$TEMP_FILE" "$MONTHLY_FILE"
    debug "Final deduplication completed"
else
    debug "Final deduplication failed"
    rm -f "$TEMP_FILE"
fi

# 4. OUTPUT FINAL JSON
if [ -f "$MONTHLY_FILE" ]; then
    jq '.' "$MONTHLY_FILE"
else
    echo '{"error": "Monthly file not found", "messages": []}'
fi

# CLEANUP
rm -f "$TEMP_FILE" "${MONTHLY_FILE}.backup" "/tmp/jq_error_$$.log" "/tmp/new_msg_$$.json"
flock -u 200

debug "=== SMS-READ END ==="
