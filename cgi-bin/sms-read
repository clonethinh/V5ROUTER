#!/bin/sh
echo "Content-Type: application/json; charset=utf-8"
echo ""

# === KI·ªÇM TRA MODE V√Ä QUERY PARAMETERS ===
MODE="${QUERY_STRING%%&*}"
DAEMON_PID_FILE="/var/run/sms-read-daemon.pid"

# === CH·ª®C NƒÇNG AUTO-DETECT ENDPOINT ===
detect_endpoint() {
    local ip_addr port endpoint
    
    # Detect IP address
    ip_addr=$(ip route get 1.1.1.1 2>/dev/null | grep -oP 'src \K\S+' | head -1)
    if [ -z "$ip_addr" ]; then
        # Fallback methods
        for iface in br-lan eth0 wlan0 enp0s3 ens33; do
            ip_addr=$(ip addr show "$iface" 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | head -1)
            [ -n "$ip_addr" ] && [ "$ip_addr" != "127.0.0.1" ] && break
        done
    fi
    [ -z "$ip_addr" ] && ip_addr="127.0.0.1"
    
    # Detect port
    for test_port in 8888 80 8080 8000 3000; do
        if ss -ln 2>/dev/null | grep -q ":$test_port.*LISTEN" || \
           netstat -ln 2>/dev/null | grep -q ":$test_port.*LISTEN"; then
            port="$test_port"
            break
        fi
    done
    [ -z "$port" ] && port="8888"
    
    endpoint="http://${ip_addr}:${port}/cgi-bin/sms-read"
    echo "$endpoint"
}

# === CH·ª®C NƒÇNG DAEMON MODE ===
# === REAL-TIME POLLING WITH MICRO DELAYS ===
if echo "$MODE" | grep -q 'daemon=1'; then
    # Ki·ªÉm tra daemon ƒë√£ ch·∫°y ch∆∞a
    if [ -f "$DAEMON_PID_FILE" ]; then
        EXISTING_PID=$(cat "$DAEMON_PID_FILE" 2>/dev/null)
        if [ -n "$EXISTING_PID" ] && ps -p "$EXISTING_PID" >/dev/null 2>&1; then
            echo '{"status":"daemon already running","pid":'$EXISTING_PID'}'
            exit 0
        else
            rm -f "$DAEMON_PID_FILE"
        fi
    fi
    
    echo '{"status":"daemon starting","message":"Real-time SMS polling daemon started"}'
    
    # Start real-time daemon
    (
        echo $$ > "$DAEMON_PID_FILE"
        ENDPOINT=$(detect_endpoint)
        
        # Real-time polling configuration
        MICRO_DELAY=0.1      # 1 gi√¢y - micro delay
        FAST_DELAY=1       # 3 gi√¢y - khi c√≥ ho·∫°t ƒë·ªông
        NORMAL_DELAY=3     # 8 gi√¢y - b√¨nh th∆∞·ªùng
        SLOW_DELAY=5      # 20 gi√¢y - khi im l·∫∑ng
        ERROR_DELAY=15     # 45 gi√¢y - khi c√≥ l·ªói
        
        # State tracking
        PREVIOUS_TOTAL=0
        PREVIOUS_UNREAD=0
        ACTIVITY_SCORE=0
        CONSECUTIVE_EMPTY=0
        POLL_COUNT=0
        
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Real-time SMS Daemon started (PID: $$)" >> "/tmp/sms-daemon.log"
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Endpoint: $ENDPOINT" >> "/tmp/sms-daemon.log"
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Delays: Micro=$MICRO_DELAY, Fast=$FAST_DELAY, Normal=$NORMAL_DELAY, Slow=$SLOW_DELAY" >> "/tmp/sms-daemon.log"
        
        # Cleanup function
        cleanup_daemon() {
            echo "$(date '+%Y-%m-%d %H:%M:%S') - Real-time SMS Daemon stopping (PID: $$)" >> "/tmp/sms-daemon.log"
            rm -f "$DAEMON_PID_FILE"
            exit 0
        }
        trap cleanup_daemon TERM INT
        
        # Main real-time polling loop
        while true; do
            POLL_COUNT=$((POLL_COUNT + 1))
            START_TIME=$(date +%s)
            
            # Re-detect endpoint m·ªói 200 polls
            if [ $((POLL_COUNT % 200)) -eq 0 ]; then
                ENDPOINT=$(detect_endpoint)
                echo "$(date '+%Y-%m-%d %H:%M:%S') - Endpoint re-detected: $ENDPOINT (poll #$POLL_COUNT)" >> "/tmp/sms-daemon.log"
            fi
            
            # Execute SMS polling
            RESPONSE=$(curl -s -m 8 "$ENDPOINT" 2>&1)
            CURL_EXIT_CODE=$?
            END_TIME=$(date +%s)
            RESPONSE_TIME=$((END_TIME - START_TIME))
            
            if [ $CURL_EXIT_CODE -eq 0 ]; then
                if command -v jq >/dev/null 2>&1; then
                    CURRENT_TOTAL=$(echo "$RESPONSE" | jq -r '.total // 0' 2>/dev/null || echo "0")
                    CURRENT_UNREAD=$(echo "$RESPONSE" | jq '[.messages[]? | select(.read_status == 0)] | length' 2>/dev/null || echo "0")
                    
                    # Calculate activity metrics
                    TOTAL_CHANGE=$((CURRENT_TOTAL - PREVIOUS_TOTAL))
                    UNREAD_CHANGE=$((CURRENT_UNREAD - PREVIOUS_UNREAD))
                    
                    # Determine polling strategy based on activity
                    if [ "$TOTAL_CHANGE" -gt 0 ]; then
                        # NEW MESSAGES DETECTED - Ultra fast polling
                        ACTIVITY_SCORE=10
                        CONSECUTIVE_EMPTY=0
                        NEXT_DELAY=$MICRO_DELAY
                        
                        echo "$(date '+%Y-%m-%d %H:%M:%S') - üö® NEW SMS! +$TOTAL_CHANGE messages (Total: $CURRENT_TOTAL, Unread: $CURRENT_UNREAD) [MICRO-DELAY: ${MICRO_DELAY}s]" >> "/tmp/sms-daemon.log"
                        
                        # Burst polling cho 30 gi√¢y khi c√≥ SMS m·ªõi
                        BURST_COUNT=30
                        while [ $BURST_COUNT -gt 0 ] && [ -f "$DAEMON_PID_FILE" ]; do
                            sleep $MICRO_DELAY
                            curl -s -m 5 "$ENDPOINT" >/dev/null 2>&1
                            BURST_COUNT=$((BURST_COUNT - 1))
                        done
                        
                    elif [ "$CURRENT_UNREAD" -gt 0 ]; then
                        # Has unread messages - Fast polling
                        ACTIVITY_SCORE=$((ACTIVITY_SCORE > 0 ? ACTIVITY_SCORE - 1 : 0))
                        CONSECUTIVE_EMPTY=0
                        
                        if [ "$ACTIVITY_SCORE" -gt 5 ]; then
                            NEXT_DELAY=$FAST_DELAY
                            STATUS="FAST"
                        else
                            NEXT_DELAY=$NORMAL_DELAY
                            STATUS="NORMAL"
                        fi
                        
                        echo "$(date '+%Y-%m-%d %H:%M:%S') - üì¨ Unread: $CURRENT_UNREAD messages (Activity: $ACTIVITY_SCORE) [$STATUS-DELAY: ${NEXT_DELAY}s]" >> "/tmp/sms-daemon.log"
                        
                    else
                        # No activity - Gradually slow down
                        CONSECUTIVE_EMPTY=$((CONSECUTIVE_EMPTY + 1))
                        ACTIVITY_SCORE=$((ACTIVITY_SCORE > 0 ? ACTIVITY_SCORE - 1 : 0))
                        
                        if [ $CONSECUTIVE_EMPTY -lt 5 ]; then
                            NEXT_DELAY=$NORMAL_DELAY
                            STATUS="NORMAL"
                        elif [ $CONSECUTIVE_EMPTY -lt 15 ]; then
                            NEXT_DELAY=$SLOW_DELAY
                            STATUS="SLOW"
                        else
                            # Adaptive slow down
                            ADAPTIVE_DELAY=$((SLOW_DELAY + CONSECUTIVE_EMPTY))
                            NEXT_DELAY=$((ADAPTIVE_DELAY > 60 ? 60 : ADAPTIVE_DELAY))
                            STATUS="ADAPTIVE"
                        fi
                        
                        # Log m·ªói 10 polls khi kh√¥ng c√≥ ho·∫°t ƒë·ªông
                        if [ $((POLL_COUNT % 10)) -eq 0 ]; then
                            echo "$(date '+%Y-%m-%d %H:%M:%S') - üí§ No activity ($CONSECUTIVE_EMPTY empty polls) [$STATUS-DELAY: ${NEXT_DELAY}s]" >> "/tmp/sms-daemon.log"
                        fi
                    fi
                    
                    # Update state
                    PREVIOUS_TOTAL="$CURRENT_TOTAL"
                    PREVIOUS_UNREAD="$CURRENT_UNREAD"
                    
                else
                    # No jq available - use conservative approach
                    NEXT_DELAY=$NORMAL_DELAY
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - Poll OK (no jq) - Response time: ${RESPONSE_TIME}s" >> "/tmp/sms-daemon.log"
                fi
                
            else
                # Polling failed
                ACTIVITY_SCORE=0
                CONSECUTIVE_EMPTY=$((CONSECUTIVE_EMPTY + 1))
                NEXT_DELAY=$ERROR_DELAY
                
                echo "$(date '+%Y-%m-%d %H:%M:%S') - ‚ùå Poll failed (exit: $CURL_EXIT_CODE) [ERROR-DELAY: ${ERROR_DELAY}s]" >> "/tmp/sms-daemon.log"
                echo "$(date '+%Y-%m-%d %H:%M:%S') - Error details: $RESPONSE" >> "/tmp/sms-daemon.log"
            fi
            
            # Performance monitoring
            if [ $((POLL_COUNT % 100)) -eq 0 ]; then
                UPTIME=$(ps -o etime= -p $$ | tr -d ' ')
                echo "$(date '+%Y-%m-%d %H:%M:%S') - üìä Performance: Poll #$POLL_COUNT, Uptime: $UPTIME, Activity: $ACTIVITY_SCORE" >> "/tmp/sms-daemon.log"
            fi
            
            # Log rotation
            if [ $((POLL_COUNT % 500)) -eq 0 ]; then
                if [ -f "/tmp/sms-daemon.log" ] && [ $(stat -c%s "/tmp/sms-daemon.log" 2>/dev/null || echo 0) -gt 2097152 ]; then
                    mv "/tmp/sms-daemon.log" "/tmp/sms-daemon.log.old"
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - üîÑ Log rotated at poll #$POLL_COUNT" >> "/tmp/sms-daemon.log"
                fi
            fi
            
            # Adaptive sleep based on response time
            if [ "$RESPONSE_TIME" -gt 3 ]; then
                # Server slow - increase delay
                NEXT_DELAY=$((NEXT_DELAY + 2))
                echo "$(date '+%Y-%m-%d %H:%M:%S') - ‚ö†Ô∏è Slow response (${RESPONSE_TIME}s), adjusted delay to ${NEXT_DELAY}s" >> "/tmp/sms-daemon.log"
            fi
            
            sleep $NEXT_DELAY
        done
    ) &
    
    exit 0
fi

# === CH·ª®C NƒÇNG STOP DAEMON ===
if echo "$MODE" | grep -q 'daemon=stop'; then
    if [ -f "$DAEMON_PID_FILE" ]; then
        DAEMON_PID=$(cat "$DAEMON_PID_FILE")
        if ps -p "$DAEMON_PID" >/dev/null 2>&1; then
            kill "$DAEMON_PID" 2>/dev/null
            sleep 2
            if ps -p "$DAEMON_PID" >/dev/null 2>&1; then
                kill -9 "$DAEMON_PID" 2>/dev/null
            fi
            rm -f "$DAEMON_PID_FILE"
            echo '{"status":"daemon stopped","pid":'$DAEMON_PID'}'
        else
            rm -f "$DAEMON_PID_FILE"
            echo '{"status":"daemon not running"}'
        fi
    else
        echo '{"status":"daemon not running"}'
    fi
    exit 0
fi

# === CH·ª®C NƒÇNG STATUS DAEMON ===
if echo "$MODE" | grep -q 'daemon=status'; then
    if [ -f "$DAEMON_PID_FILE" ]; then
        DAEMON_PID=$(cat "$DAEMON_PID_FILE")
        if ps -p "$DAEMON_PID" >/dev/null 2>&1; then
            UPTIME=$(ps -o etime= -p "$DAEMON_PID" | tr -d ' ')
            echo '{"status":"daemon running","pid":'$DAEMON_PID',"uptime":"'$UPTIME'"}'
        else
            rm -f "$DAEMON_PID_FILE"
            echo '{"status":"daemon not running","note":"stale pid file removed"}'
        fi
    else
        echo '{"status":"daemon not running"}'
    fi
    exit 0
fi

# === DEBUG LOG ===
DEBUG_LOG="/tmp/sms-read-debug.log"
debug() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$DEBUG_LOG"
}

debug "=== SMS-READ START ==="

# === C·∫§U H√åNH ===
ARCHIVE_DIR="/root/sms-archive"
mkdir -p "$ARCHIVE_DIR"

CURRENT_MONTH=$(date "+%Y-%m")
MONTHLY_FILE="$ARCHIVE_DIR/messages-${CURRENT_MONTH}.json"
TEMP_FILE="/tmp/messages_temp_$$.json"

debug "Monthly file: $MONTHLY_FILE"

# === KH·ªûI T·∫†O MONTHLY FILE ===
init_monthly_file() {
    if [ ! -f "$MONTHLY_FILE" ] || [ ! -s "$MONTHLY_FILE" ]; then
        debug "Creating/recreating monthly file"
        
        # T·∫°o dynamic values
        CURRENT_MONTH_INIT=$(date "+%Y-%m")
        CURRENT_TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
        
        cat > "$MONTHLY_FILE" << EOF
{
  "month": "$CURRENT_MONTH_INIT",
  "messages": [],
  "total": 0,
  "last_updated": "$CURRENT_TIMESTAMP"
}
EOF
    else
        debug "Monthly file exists"
        if command -v jq >/dev/null 2>&1; then
            if ! jq . "$MONTHLY_FILE" >/dev/null 2>&1; then
                debug "Monthly file corrupt, recreating"
                
                CURRENT_MONTH_INIT=$(date "+%Y-%m")
                CURRENT_TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
                
                cat > "$MONTHLY_FILE" << EOF
{
  "month": "$CURRENT_MONTH_INIT", 
  "messages": [],
  "total": 0,
  "last_updated": "$CURRENT_TIMESTAMP"
}
EOF
            fi
        fi
    fi
}

# === FILE LOCKING ===
exec 200>"$MONTHLY_FILE.lock"
if ! flock -n 200; then
    debug "Could not acquire lock"
    echo '{ "messages": [] }'
    exit 1
fi

init_monthly_file

# === ESCAPE JSON SAFELY ===
escape_json_text() {
    local text="$1"
    echo "$text" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\r/\\r/g'
}

# === TH√äM MESSAGE V√ÄO MONTHLY FILE - ƒê√É S·ª¨A L·ªñI DUPLICATE ===
add_to_monthly() {
    local new_message="$1"
    debug "Adding message to monthly file"
    
    # Extract message ID ƒë·ªÉ check duplicate
    local message_id
    if command -v jq >/dev/null 2>&1; then
        message_id=$(echo "$new_message" | jq -r '.id' 2>/dev/null)
    else
        # Fallback parsing n·∫øu kh√¥ng c√≥ jq
        message_id=$(echo "$new_message" | sed -n 's/.*"id":[[:space:]]*\([0-9]*\).*/\1/p')
    fi
    
    # Check if message ID already exists
    if [ -n "$message_id" ] && [ -f "$MONTHLY_FILE" ]; then
        if command -v jq >/dev/null 2>&1; then
            if jq -e ".messages[]? | select(.id == $message_id)" "$MONTHLY_FILE" >/dev/null 2>&1; then
                debug "Message ID $message_id already exists, skipping duplicate"
                return 0
            fi
        else
            # Fallback check v·ªõi grep
            if grep -q "\"id\":[[:space:]]*$message_id[^0-9]" "$MONTHLY_FILE" 2>/dev/null; then
                debug "Message ID $message_id already exists, skipping duplicate"
                return 0
            fi
        fi
    fi
    
    debug "Message ID $message_id is new, proceeding to add"
    
    # Backup
    cp "$MONTHLY_FILE" "${MONTHLY_FILE}.backup" 2>/dev/null
    
    if command -v jq >/dev/null 2>&1; then
        debug "Using jq for JSON processing"
        
        echo "$new_message" > /tmp/new_msg_$$.json
        
        if ! jq . /tmp/new_msg_$$.json >/dev/null 2>&1; then
            debug "New message JSON is invalid"
            rm -f /tmp/new_msg_$$.json
            return 1
        fi
        
        debug "New message JSON is valid"
        
        CURRENT_TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
        
        jq --slurpfile new_msg /tmp/new_msg_$$.json \
           --arg timestamp "$CURRENT_TIMESTAMP" '
            .messages += $new_msg |
            .total = (.messages | length) |
            .last_updated = $timestamp
        ' "$MONTHLY_FILE" > "$TEMP_FILE" 2>/tmp/jq_error_$$.log
        
        rm -f /tmp/new_msg_$$.json
        
        if [ -s "$TEMP_FILE" ] && jq . "$TEMP_FILE" >/dev/null 2>&1; then
            debug "jq processing successful for message ID $message_id"
        else
            debug "jq processing failed"
            if [ -f /tmp/jq_error_$$.log ]; then
                debug "jq error: $(cat /tmp/jq_error_$$.log)"
                cat /tmp/jq_error_$$.log >> /tmp/jq_error.log
            fi
            rm -f "$TEMP_FILE" /tmp/jq_error_$$.log
        fi
    else
        debug "Using awk for JSON processing (fallback)"
        awk -v new_msg="$new_message" '
        BEGIN { found_array = 0; added = 0 }
        /^[[:space:]]*"messages"[[:space:]]*:[[:space:]]*\[/ {
            print $0
            found_array = 1
            next
        }
        found_array && /^[[:space:]]*\]/ {
            if (!added && new_msg != "") {
                print "    " new_msg
                added = 1
            }
            print $0
            found_array = 0
            next
        }
        /"last_updated"/ {
            gsub(/"[^"]*"$/, "\"" strftime("%Y-%m-%d %H:%M:%S") "\"", $0)
        }
        { print }
        ' "$MONTHLY_FILE" > "$TEMP_FILE"
    fi
    
    if [ -s "$TEMP_FILE" ]; then
        mv "$TEMP_FILE" "$MONTHLY_FILE"
        debug "Successfully added message ID $message_id to monthly file"
        return 0
    else
        debug "Failed to create temp file or temp file empty"
        if [ -f "${MONTHLY_FILE}.backup" ]; then
            mv "${MONTHLY_FILE}.backup" "$MONTHLY_FILE"
            debug "Rolled back to backup"
        fi
        return 1
    fi
}

# === CLEANUP DUPLICATE ENTRIES ===
cleanup_duplicates() {
    debug "Starting duplicate cleanup"
    
    if [ ! -f "$MONTHLY_FILE" ]; then
        debug "Monthly file doesn't exist, skipping cleanup"
        return 0
    fi
    
    # Backup tr∆∞·ªõc khi cleanup
    cp "$MONTHLY_FILE" "${MONTHLY_FILE}.cleanup_backup" 2>/dev/null
    
    if command -v jq >/dev/null 2>&1; then
        debug "Using jq for duplicate cleanup"
        
        # Count before cleanup
        BEFORE_COUNT=$(jq '.messages | length' "$MONTHLY_FILE" 2>/dev/null || echo "0")
        
        # Group by ID v√† ch·ªâ l·∫•y ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n c·ªßa m·ªói group
        jq '
            .messages |= (
                group_by(.id) | 
                map(.[0])
            ) |
            .total = (.messages | length) |
            .last_updated = (now | strftime("%Y-%m-%d %H:%M:%S"))
        ' "$MONTHLY_FILE" > "$TEMP_FILE" 2>/dev/null
        
        if [ -s "$TEMP_FILE" ] && jq . "$TEMP_FILE" >/dev/null 2>&1; then
            mv "$TEMP_FILE" "$MONTHLY_FILE"
            
            # Count after cleanup
            AFTER_COUNT=$(jq '.messages | length' "$MONTHLY_FILE" 2>/dev/null || echo "0")
            REMOVED_COUNT=$((BEFORE_COUNT - AFTER_COUNT))
            
            debug "Duplicate cleanup completed: $BEFORE_COUNT -> $AFTER_COUNT messages (removed $REMOVED_COUNT duplicates)"
            rm -f "${MONTHLY_FILE}.cleanup_backup"
            return 0
        else
            debug "Duplicate cleanup failed, restoring backup"
            if [ -f "${MONTHLY_FILE}.cleanup_backup" ]; then
                mv "${MONTHLY_FILE}.cleanup_backup" "$MONTHLY_FILE"
            fi
            rm -f "$TEMP_FILE"
            return 1
        fi
    else
        debug "jq not available, skipping duplicate cleanup"
        rm -f "${MONTHLY_FILE}.cleanup_backup"
        return 0
    fi
}

# === X√ìA SMS V·ªöI RETRY MECHANISM ===
delete_sms_with_retry() {
    local sms_id="$1"
    local retry_count=3
    
    for i in $(seq 1 $retry_count); do
        if mmcli -m 0 --messaging-delete-sms="$sms_id" >/dev/null 2>&1; then
            debug "Successfully deleted SMS $sms_id from SIM (attempt $i)"
            return 0
        else
            debug "Failed to delete SMS $sms_id from SIM (attempt $i)"
            sleep 1
        fi
    done
    
    debug "Failed to delete SMS $sms_id from SIM after $retry_count attempts"
    return 1
}

# === ƒê·ªåC MESSAGES T·ª™ ARCHIVE ===
read_archive_messages() {
    debug "Reading messages from archive"
    if [ -f "$MONTHLY_FILE" ] && command -v jq >/dev/null 2>&1; then
        jq -r '.messages[]? | @json' "$MONTHLY_FILE" 2>/dev/null
    fi
}

# === MAIN PROCESSING ===
debug "Starting main processing"

PROCESSED_COUNT=0

# 1. L·∫§Y DANH S√ÅCH SMS T·ª™ MODEM
SMS_LIST=$(mmcli -m 0 --messaging-list-sms 2>/dev/null)
debug "Raw SMS list: $SMS_LIST"

SMS_IDS=""
if [ -n "$SMS_LIST" ]; then
    # S·∫Øp x·∫øp gi·∫£m d·∫ßn ƒë·ªÉ x·ª≠ l√Ω tin nh·∫Øn m·ªõi nh·∫•t tr∆∞·ªõc
    SMS_IDS=$(echo "$SMS_LIST" | grep -oE '/SMS/[0-9]+' | sed 's|/SMS/||g' | sort -nr)
    debug "Extracted SMS IDs (sorted desc): $SMS_IDS"
fi

# 2. X·ª¨ L√ù TIN NH·∫ÆN M·ªöI
for ID in $SMS_IDS; do
    [ -n "$ID" ] || continue
    
    debug "Processing SMS ID: $ID"
    
    INFO=$(mmcli -s "$ID" 2>/dev/null)
    if [ -z "$INFO" ]; then
        debug "No info returned for SMS $ID"
        continue
    fi
    
    NUMBER=$(echo "$INFO" | grep "number:" | head -1 | sed 's/.*number:[[:space:]]*//')
    RAW_TEXT=$(echo "$INFO" | grep "text:" | head -1 | sed 's/.*text:[[:space:]]*//')
    TYPE=$(echo "$INFO" | grep "pdu type:" | head -1 | sed 's/.*pdu type:[[:space:]]*//')
    STATE=$(echo "$INFO" | grep "state:" | head -1 | sed 's/.*state:[[:space:]]*//')
    DATE=$(echo "$INFO" | grep "timestamp:" | head -1 | sed 's/.*timestamp:[[:space:]]*//')
    
    debug "SMS $ID - Number: $NUMBER, Raw Text: $RAW_TEXT, Type: $TYPE, State: $STATE"
    
    if [ -z "$RAW_TEXT" ] || [ "$STATE" = "receiving" ]; then
        debug "No text or receiving state for SMS $ID, skipping"
        continue
    fi
    
    # Fix timezone format n·∫øu c·∫ßn
    if echo "$DATE" | grep -qE '\+[0-9]{2}$'; then
        DATE=$(echo "$DATE" | sed 's/+\([0-9][0-9]\)$/+\1:00/')
    fi
    
    TEXT_ESC=$(escape_json_text "$RAW_TEXT")
    NUMBER_ESC=$(escape_json_text "$NUMBER")
    
    # X√°c ƒë·ªãnh read_status m·∫∑c ƒë·ªãnh theo lo·∫°i tin nh·∫Øn
    READ_STATUS=1
    if [ "$TYPE" = "deliver" ]; then
        READ_STATUS=0
    fi

    NEW_MESSAGE="{
  \"id\": $ID,
  \"number\": \"$NUMBER_ESC\",
  \"text\": \"$TEXT_ESC\",
  \"date\": \"$DATE\",
  \"type\": \"$TYPE\",
  \"state\": \"$STATE\",
  \"storage\": \"router\",
  \"read_status\": $READ_STATUS
}"

    debug "Created JSON for SMS $ID"
    
    if add_to_monthly "$NEW_MESSAGE"; then
        debug "Successfully saved SMS $ID to archive"
        
        # X√≥a SMS kh·ªèi SIM sau khi l∆∞u v·ªõi retry mechanism
        if delete_sms_with_retry "$ID"; then
            debug "SMS $ID deleted from SIM successfully"
        else
            debug "WARNING: SMS $ID saved to archive but failed to delete from SIM"
        fi
        
        PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
    else
        debug "Failed to save SMS $ID to archive"
    fi
done

debug "Finished processing. Total new messages: $PROCESSED_COUNT"

# === CLEANUP DUPLICATES TR∆Ø·ªöC KHI OUTPUT ===
cleanup_duplicates

# 3. IN RA JSON CHU·∫®N V·ªöI M·∫¢NG MESSAGES ƒê∆Ø·ª¢C S·∫ÆP X·∫æP GI·∫¢M D·∫¶N THEO ID
if [ -f "$MONTHLY_FILE" ]; then
    if command -v jq >/dev/null 2>&1; then
        jq '.messages |= sort_by(.id) | .messages |= reverse' "$MONTHLY_FILE"
    else
        # Fallback n·∫øu kh√¥ng c√≥ jq
        cat "$MONTHLY_FILE"
    fi
else
    echo '{ "messages": [], "total": 0 }'
fi

# CLEANUP
rm -f "$TEMP_FILE" "${MONTHLY_FILE}.backup" "${MONTHLY_FILE}.cleanup_backup" /tmp/jq_error_$$.log /tmp/new_msg_$$.json
flock -u 200

debug "=== SMS-READ END ==="
