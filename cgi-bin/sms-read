#!/bin/sh
echo "Content-Type: application/json; charset=utf-8"
echo ""

# === DEBUG LOG ===
DEBUG_LOG="/tmp/sms-read-debug.log"
debug() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$DEBUG_LOG"
}

debug "=== SMS-READ START ==="

# === CẤU HÌNH ===
ARCHIVE_DIR="/root/sms-archive"
mkdir -p "$ARCHIVE_DIR"

CURRENT_MONTH=$(date "+%Y-%m")
MONTHLY_FILE="$ARCHIVE_DIR/messages-${CURRENT_MONTH}.json"
TEMP_FILE="/tmp/messages_temp_$$.json"

debug "Monthly file: $MONTHLY_FILE"

# === KHỞI TẠO MONTHLY FILE ===
init_monthly_file() {
    if [ ! -f "$MONTHLY_FILE" ] || [ ! -s "$MONTHLY_FILE" ]; then
        debug "Creating/recreating monthly file"
        
        # Tạo dynamic values
        CURRENT_MONTH_INIT=$(date "+%Y-%m")
        CURRENT_TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
        
        cat > "$MONTHLY_FILE" << EOF
{
  "month": "$CURRENT_MONTH_INIT",
  "messages": [],
  "total": 0,
  "last_updated": "$CURRENT_TIMESTAMP"
}
EOF
    else
        debug "Monthly file exists"
        if command -v jq >/dev/null 2>&1; then
            if ! jq . "$MONTHLY_FILE" >/dev/null 2>&1; then
                debug "Monthly file corrupt, recreating"
                
                CURRENT_MONTH_INIT=$(date "+%Y-%m")
                CURRENT_TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
                
                cat > "$MONTHLY_FILE" << EOF
{
  "month": "$CURRENT_MONTH_INIT", 
  "messages": [],
  "total": 0,
  "last_updated": "$CURRENT_TIMESTAMP"
}
EOF
            fi
        fi
    fi
}

# === FILE LOCKING ===
exec 200>"$MONTHLY_FILE.lock"
if ! flock -n 200; then
    debug "Could not acquire lock"
    echo '{ "messages": [] }'
    exit 1
fi

init_monthly_file

# === ESCAPE JSON SAFELY ===
escape_json_text() {
    local text="$1"
    echo "$text" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\r/\\r/g'
}

# === THÊM MESSAGE VÀO MONTHLY FILE - ĐÃ SỬA LỖI DUPLICATE ===
add_to_monthly() {
    local new_message="$1"
    debug "Adding message to monthly file"
    
    # Extract message ID để check duplicate
    local message_id
    if command -v jq >/dev/null 2>&1; then
        message_id=$(echo "$new_message" | jq -r '.id' 2>/dev/null)
    else
        # Fallback parsing nếu không có jq
        message_id=$(echo "$new_message" | sed -n 's/.*"id":[[:space:]]*\([0-9]*\).*/\1/p')
    fi
    
    # Check if message ID already exists
    if [ -n "$message_id" ] && [ -f "$MONTHLY_FILE" ]; then
        if command -v jq >/dev/null 2>&1; then
            if jq -e ".messages[]? | select(.id == $message_id)" "$MONTHLY_FILE" >/dev/null 2>&1; then
                debug "Message ID $message_id already exists, skipping duplicate"
                return 0
            fi
        else
            # Fallback check với grep
            if grep -q "\"id\":[[:space:]]*$message_id[^0-9]" "$MONTHLY_FILE" 2>/dev/null; then
                debug "Message ID $message_id already exists, skipping duplicate"
                return 0
            fi
        fi
    fi
    
    debug "Message ID $message_id is new, proceeding to add"
    
    # Backup
    cp "$MONTHLY_FILE" "${MONTHLY_FILE}.backup" 2>/dev/null
    
    if command -v jq >/dev/null 2>&1; then
        debug "Using jq for JSON processing"
        
        echo "$new_message" > /tmp/new_msg_$$.json
        
        if ! jq . /tmp/new_msg_$$.json >/dev/null 2>&1; then
            debug "New message JSON is invalid"
            rm -f /tmp/new_msg_$$.json
            return 1
        fi
        
        debug "New message JSON is valid"
        
        CURRENT_TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
        
        jq --slurpfile new_msg /tmp/new_msg_$$.json \
           --arg timestamp "$CURRENT_TIMESTAMP" '
            .messages += $new_msg |
            .total = (.messages | length) |
            .last_updated = $timestamp
        ' "$MONTHLY_FILE" > "$TEMP_FILE" 2>/tmp/jq_error_$$.log
        
        rm -f /tmp/new_msg_$$.json
        
        if [ -s "$TEMP_FILE" ] && jq . "$TEMP_FILE" >/dev/null 2>&1; then
            debug "jq processing successful for message ID $message_id"
        else
            debug "jq processing failed"
            if [ -f /tmp/jq_error_$$.log ]; then
                debug "jq error: $(cat /tmp/jq_error_$$.log)"
                cat /tmp/jq_error_$$.log >> /tmp/jq_error.log
            fi
            rm -f "$TEMP_FILE" /tmp/jq_error_$$.log
        fi
    else
        debug "Using awk for JSON processing (fallback)"
        awk -v new_msg="$new_message" '
        BEGIN { found_array = 0; added = 0 }
        /^[[:space:]]*"messages"[[:space:]]*:[[:space:]]*\[/ {
            print $0
            found_array = 1
            next
        }
        found_array && /^[[:space:]]*\]/ {
            if (!added && new_msg != "") {
                print "    " new_msg
                added = 1
            }
            print $0
            found_array = 0
            next
        }
        /"last_updated"/ {
            gsub(/"[^"]*"$/, "\"" strftime("%Y-%m-%d %H:%M:%S") "\"", $0)
        }
        { print }
        ' "$MONTHLY_FILE" > "$TEMP_FILE"
    fi
    
    if [ -s "$TEMP_FILE" ]; then
        mv "$TEMP_FILE" "$MONTHLY_FILE"
        debug "Successfully added message ID $message_id to monthly file"
        return 0
    else
        debug "Failed to create temp file or temp file empty"
        if [ -f "${MONTHLY_FILE}.backup" ]; then
            mv "${MONTHLY_FILE}.backup" "$MONTHLY_FILE"
            debug "Rolled back to backup"
        fi
        return 1
    fi
}

# === CLEANUP DUPLICATE ENTRIES ===
cleanup_duplicates() {
    debug "Starting duplicate cleanup"
    
    if [ ! -f "$MONTHLY_FILE" ]; then
        debug "Monthly file doesn't exist, skipping cleanup"
        return 0
    fi
    
    # Backup trước khi cleanup
    cp "$MONTHLY_FILE" "${MONTHLY_FILE}.cleanup_backup" 2>/dev/null
    
    if command -v jq >/dev/null 2>&1; then
        debug "Using jq for duplicate cleanup"
        
        # Count before cleanup
        BEFORE_COUNT=$(jq '.messages | length' "$MONTHLY_FILE" 2>/dev/null || echo "0")
        
        # Group by ID và chỉ lấy phần tử đầu tiên của mỗi group
        jq '
            .messages |= (
                group_by(.id) | 
                map(.[0])
            ) |
            .total = (.messages | length) |
            .last_updated = (now | strftime("%Y-%m-%d %H:%M:%S"))
        ' "$MONTHLY_FILE" > "$TEMP_FILE" 2>/dev/null
        
        if [ -s "$TEMP_FILE" ] && jq . "$TEMP_FILE" >/dev/null 2>&1; then
            mv "$TEMP_FILE" "$MONTHLY_FILE"
            
            # Count after cleanup
            AFTER_COUNT=$(jq '.messages | length' "$MONTHLY_FILE" 2>/dev/null || echo "0")
            REMOVED_COUNT=$((BEFORE_COUNT - AFTER_COUNT))
            
            debug "Duplicate cleanup completed: $BEFORE_COUNT -> $AFTER_COUNT messages (removed $REMOVED_COUNT duplicates)"
            rm -f "${MONTHLY_FILE}.cleanup_backup"
            return 0
        else
            debug "Duplicate cleanup failed, restoring backup"
            if [ -f "${MONTHLY_FILE}.cleanup_backup" ]; then
                mv "${MONTHLY_FILE}.cleanup_backup" "$MONTHLY_FILE"
            fi
            rm -f "$TEMP_FILE"
            return 1
        fi
    else
        debug "jq not available, skipping duplicate cleanup"
        rm -f "${MONTHLY_FILE}.cleanup_backup"
        return 0
    fi
}

# === XÓA SMS VỚI RETRY MECHANISM ===
delete_sms_with_retry() {
    local sms_id="$1"
    local retry_count=3
    
    for i in $(seq 1 $retry_count); do
        if mmcli -m 0 --messaging-delete-sms="$sms_id" >/dev/null 2>&1; then
            debug "Successfully deleted SMS $sms_id from SIM (attempt $i)"
            return 0
        else
            debug "Failed to delete SMS $sms_id from SIM (attempt $i)"
            sleep 1
        fi
    done
    
    debug "Failed to delete SMS $sms_id from SIM after $retry_count attempts"
    return 1
}

# === ĐỌC MESSAGES TỪ ARCHIVE ===
read_archive_messages() {
    debug "Reading messages from archive"
    if [ -f "$MONTHLY_FILE" ] && command -v jq >/dev/null 2>&1; then
        jq -r '.messages[]? | @json' "$MONTHLY_FILE" 2>/dev/null
    fi
}

# === MAIN PROCESSING ===
debug "Starting main processing"

PROCESSED_COUNT=0

# 1. LẤY DANH SÁCH SMS TỪ MODEM
SMS_LIST=$(mmcli -m 0 --messaging-list-sms 2>/dev/null)
debug "Raw SMS list: $SMS_LIST"

SMS_IDS=""
if [ -n "$SMS_LIST" ]; then
    # Sắp xếp giảm dần để xử lý tin nhắn mới nhất trước
    SMS_IDS=$(echo "$SMS_LIST" | grep -oE '/SMS/[0-9]+' | sed 's|/SMS/||g' | sort -nr)
    debug "Extracted SMS IDs (sorted desc): $SMS_IDS"
fi

# 2. XỬ LÝ TIN NHẮN MỚI
for ID in $SMS_IDS; do
    [ -n "$ID" ] || continue
    
    debug "Processing SMS ID: $ID"
    
    INFO=$(mmcli -s "$ID" 2>/dev/null)
    if [ -z "$INFO" ]; then
        debug "No info returned for SMS $ID"
        continue
    fi
    
    NUMBER=$(echo "$INFO" | grep "number:" | head -1 | sed 's/.*number:[[:space:]]*//')
    RAW_TEXT=$(echo "$INFO" | grep "text:" | head -1 | sed 's/.*text:[[:space:]]*//')
    TYPE=$(echo "$INFO" | grep "pdu type:" | head -1 | sed 's/.*pdu type:[[:space:]]*//')
    STATE=$(echo "$INFO" | grep "state:" | head -1 | sed 's/.*state:[[:space:]]*//')
    DATE=$(echo "$INFO" | grep "timestamp:" | head -1 | sed 's/.*timestamp:[[:space:]]*//')
    
    debug "SMS $ID - Number: $NUMBER, Raw Text: $RAW_TEXT, Type: $TYPE, State: $STATE"
    
    if [ -z "$RAW_TEXT" ] || [ "$STATE" = "receiving" ]; then
        debug "No text or receiving state for SMS $ID, skipping"
        continue
    fi
    
    # Fix timezone format nếu cần
    if echo "$DATE" | grep -qE '\+[0-9]{2}$'; then
        DATE=$(echo "$DATE" | sed 's/+\([0-9][0-9]\)$/+\1:00/')
    fi
    
    TEXT_ESC=$(escape_json_text "$RAW_TEXT")
    NUMBER_ESC=$(escape_json_text "$NUMBER")
    
    # Xác định read_status mặc định theo loại tin nhắn
    READ_STATUS=1
    if [ "$TYPE" = "deliver" ]; then
        READ_STATUS=0
    fi

    NEW_MESSAGE="{
  \"id\": $ID,
  \"number\": \"$NUMBER_ESC\",
  \"text\": \"$TEXT_ESC\",
  \"date\": \"$DATE\",
  \"type\": \"$TYPE\",
  \"state\": \"$STATE\",
  \"storage\": \"router\",
  \"read_status\": $READ_STATUS
}"

    debug "Created JSON for SMS $ID"
    
    if add_to_monthly "$NEW_MESSAGE"; then
        debug "Successfully saved SMS $ID to archive"
        
        # Xóa SMS khỏi SIM sau khi lưu với retry mechanism
        if delete_sms_with_retry "$ID"; then
            debug "SMS $ID deleted from SIM successfully"
        else
            debug "WARNING: SMS $ID saved to archive but failed to delete from SIM"
        fi
        
        PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
    else
        debug "Failed to save SMS $ID to archive"
    fi
done

debug "Finished processing. Total new messages: $PROCESSED_COUNT"

# === CLEANUP DUPLICATES TRƯỚC KHI OUTPUT ===
cleanup_duplicates

# 3. IN RA JSON CHUẨN VỚI MẢNG MESSAGES ĐƯỢC SẮP XẾP GIẢM DẦN THEO ID
if [ -f "$MONTHLY_FILE" ]; then
    if command -v jq >/dev/null 2>&1; then
        jq '.messages |= sort_by(.id) | .messages |= reverse' "$MONTHLY_FILE"
    else
        # Fallback nếu không có jq
        cat "$MONTHLY_FILE"
    fi
else
    echo '{ "messages": [], "total": 0 }'
fi

# CLEANUP
rm -f "$TEMP_FILE" "${MONTHLY_FILE}.backup" "${MONTHLY_FILE}.cleanup_backup" /tmp/jq_error_$$.log /tmp/new_msg_$$.json
flock -u 200

debug "=== SMS-READ END ==="
